# shogi_mvp.py
# CUI将棋MVP：盤・駒の動き・成り・持ち駒・打ち（簡易）
# 未実装：王手/詰み判定、王手放置禁止、千日手、打ち歩詰め等

from __future__ import annotations
from dataclasses import dataclass
from typing import Optional, List, Tuple, Dict

FILES = "123456789"          # 1..9
RANKS = "abcdefghi"          # a..i  (aが上、iが下)
PROMO_ZONE_BLACK = set([0, 1, 2])  # 先手(Black)の成りゾーン（相手陣）= 上3段
PROMO_ZONE_WHITE = set([6, 7, 8])  # 後手(White)の成りゾーン（相手陣）= 下3段

# 表示用：先手は大文字、後手は小文字
# 成駒は + を付けて表示（例：+P）
PIECE_ORDER = ["K", "R", "B", "G", "S", "N", "L", "P"]

PROMOTABLE = set(["P", "L", "N", "S", "B", "R"])
PROMOTED_MAP = {
    "P": "+P",
    "L": "+L",
    "N": "+N",
    "S": "+S",
    "B": "+B",
    "R": "+R",
}
UNPROMOTE_MAP = {v: k for k, v in PROMOTED_MAP.items()}

# 金相当の成駒（と金/成香/成桂/成銀）は動きが同じ
GOLD_LIKE = set(["G", "+P", "+L", "+N", "+S"])

@dataclass(frozen=True)
class Piece:
    kind: str          # "P" "L" ... "+P" "+R" etc
    color: str         # "B" (先手) or "W" (後手)

    def base_kind(self) -> str:
        return UNPROMOTE_MAP.get(self.kind, self.kind)

    def is_promoted(self) -> bool:
        return self.kind.startswith("+")

    def can_promote(self) -> bool:
        return self.base_kind() in PROMOTABLE and not self.is_promoted()

    def display(self) -> str:
        s = self.kind
        if self.color == "W":
            # 後手は小文字表示
            s = s.lower()
        return s

def sq_to_xy(sq: str) -> Tuple[int, int]:
    # "7f" -> (file_index, rank_index)  file: '1'..'9' => 0..8, rank: 'a'..'i' => 0..8
    if len(sq) != 2 or sq[0] not in FILES or sq[1] not in RANKS:
        raise ValueError("square format must be like 7f")
    x = FILES.index(sq[0])
    y = RANKS.index(sq[1])
    return x, y

def xy_to_sq(x: int, y: int) -> str:
    return FILES[x] + RANKS[y]

def inside(x: int, y: int) -> bool:
    return 0 <= x < 9 and 0 <= y < 9

class Shogi:
    def __init__(self):
        self.board: List[List[Optional[Piece]]] = [[None for _ in range(9)] for _ in range(9)]
        self.hands: Dict[str, Dict[str, int]] = {
            "B": {k: 0 for k in PIECE_ORDER},
            "W": {k: 0 for k in PIECE_ORDER},
        }
        self.turn: str = "B"  # "B"先手, "W"後手
        self.reset()

    def reset(self):
        # 初期配置（一般的な将棋の並び）
        self.board = [[None for _ in range(9)] for _ in range(9)]

        # 1段目（後手陣）: l n s g k g s n l
        back = ["L", "N", "S", "G", "K", "G", "S", "N", "L"]
        for x, k in enumerate(back):
            self.board[0][x] = Piece(k, "W")
        # 2段目（後手）： r と b
        self.board[1][1] = Piece("B", "W")  # 2bに角（ここは座標系の都合で一般表記と異なるが盤面表示で整合）
        self.board[1][7] = Piece("R", "W")
        # 3段目（後手）：歩
        for x in range(9):
            self.board[2][x] = Piece("P", "W")

        # 7段目（先手）：歩
        for x in range(9):
            self.board[6][x] = Piece("P", "B")
        # 8段目（先手）：角と飛
        self.board[7][1] = Piece("R", "B")
        self.board[7][7] = Piece("B", "B")
        # 9段目（先手）: L N S G K G S N L
        for x, k in enumerate(back):
            self.board[8][x] = Piece(k, "B")

        self.hands = {
            "B": {k: 0 for k in PIECE_ORDER},
            "W": {k: 0 for k in PIECE_ORDER},
        }
        self.turn = "B"

    def promo_zone(self, color: str) -> set:
        return PROMO_ZONE_BLACK if color == "B" else PROMO_ZONE_WHITE

    def forward_dir(self, color: str) -> int:
        # 先手は上へ(-1)、後手は下へ(+1)
        return -1 if color == "B" else 1

    def get(self, x: int, y: int) -> Optional[Piece]:
        return self.board[y][x]

    def set(self, x: int, y: int, p: Optional[Piece]):
        self.board[y][x] = p

    def print_board(self):
        # 上(a=0)から下(i=8)
        print("\n    " + " ".join(FILES))
        for y in range(9):
            row = []
            for x in range(9):
                p = self.board[y][x]
                if p is None:
                    row.append(" . ")
                else:
                    s = p.display()
                    # 2文字(例:+p)もあるので幅合わせ
                    if len(s) == 1:
                        row.append(f" {s} ")
                    else:
                        row.append(f"{s:>3}")
            print(f"{RANKS[y]} " + "".join(row))
        print()

        def hand_str(color: str) -> str:
            parts = []
            for k in PIECE_ORDER:
                c = self.hands[color][k]
                if c > 0:
                    parts.append(f"{k}{c}")
            return " ".join(parts) if parts else "(none)"

        print(f"Turn: {'Black(先手)' if self.turn=='B' else 'White(後手)'}")
        print(f"Black hand: {hand_str('B')}")
        print(f"White hand: {hand_str('W')}")
        print()

    def opponent(self, color: str) -> str:
        return "W" if color == "B" else "B"

    def add_to_hand(self, color: str, captured: Piece):
        # 取った駒は成りを戻して持ち駒化
        base = captured.base_kind()
        if base == "K":
            # 玉は取ったら終了扱いが普通だが、このMVPでは単に許容しない
            # （実戦では玉は取れない＝詰みで終了）
            return
        self.hands[color][base] += 1

    def can_drop_pawn(self, color: str, x: int, y: int) -> bool:
        # 二歩チェック：同じ筋に未成の歩があると不可
        for yy in range(9):
            p = self.get(x, yy)
            if p and p.color == color and p.kind == "P":
                return False
        # 最終段への歩打ちは不可（動けないため）
        if (color == "B" and y == 0) or (color == "W" and y == 8):
            return False
        return True

    def drop(self, piece_kind: str, to_x: int, to_y: int) -> bool:
        color = self.turn
        piece_kind = piece_kind.upper()
        if piece_kind not in self.hands[color]:
            print("Invalid piece for drop.")
            return False
        if self.hands[color][piece_kind] <= 0:
            print("You don't have that piece in hand.")
            return False
        if self.get(to_x, to_y) is not None:
            print("Target square is not empty.")
            return False

        # 簡易の打ち制約
        if piece_kind == "P" and not self.can_drop_pawn(color, to_x, to_y):
            print("Illegal pawn drop (二歩 or last-rank pawn).")
            return False
        if piece_kind == "L":
            # 香は最終段不可（動けない）
            if (color == "B" and to_y == 0) or (color == "W" and to_y == 8):
                print("Illegal lance drop on last rank.")
                return False
        if piece_kind == "N":
            # 桂は最終段/その1つ手前不可（動けない）
            if (color == "B" and to_y <= 1) or (color == "W" and to_y >= 7):
                print("Illegal knight drop on last two ranks.")
                return False

        self.set(to_x, to_y, Piece(piece_kind, color))
        self.hands[color][piece_kind] -= 1
        self.turn = self.opponent(self.turn)
        return True

    def moves_for(self, x: int, y: int) -> List[Tuple[int, int, bool]]:
        # (to_x, to_y, sliding) 的に生成してもいいが、ここは合法先だけ返す
        p = self.get(x, y)
        if not p:
            return []
        color = p.color
        f = self.forward_dir(color)

        def add_step(dx: int, dy: int, acc: List[Tuple[int, int]],):
            tx, ty = x + dx, y + dy
            if not inside(tx, ty):
                return
            t = self.get(tx, ty)
            if t is None or t.color != color:
                acc.append((tx, ty))

        def add_slide(dx: int, dy: int, acc: List[Tuple[int, int]]):
            tx, ty = x + dx, y + dy
            while inside(tx, ty):
                t = self.get(tx, ty)
                if t is None:
                    acc.append((tx, ty))
                else:
                    if t.color != color:
                        acc.append((tx, ty))
                    break
                tx += dx
                ty += dy

        acc: List[Tuple[int, int]] = []
        k = p.kind

        if k in ["K", "k"]:
            for dx in (-1, 0, 1):
                for dy in (-1, 0, 1):
                    if dx == 0 and dy == 0:
                        continue
                    add_step(dx, dy, acc)

        elif k in GOLD_LIKE or k in [s.lower() for s in GOLD_LIKE]:
            # 金：前/前斜/横/後
            steps = [(0, f), (-1, f), (1, f), (-1, 0), (1, 0), (0, -f)]
            for dx, dy in steps:
                add_step(dx, dy, acc)

        elif k in ["S", "s"]:
            # 銀：前/前斜/後斜
            steps = [(0, f), (-1, f), (1, f), (-1, -f), (1, -f)]
            for dx, dy in steps:
                add_step(dx, dy, acc)

        elif k in ["N", "n"]:
            # 桂：前に2、左右1
            for dx in (-1, 1):
                tx, ty = x + dx, y + 2*f
                if inside(tx, ty):
                    t = self.get(tx, ty)
                    if t is None or t.color != color:
                        acc.append((tx, ty))

        elif k in ["L", "l"]:
            # 香：前に滑走
            add_slide(0, f, acc)

        elif k in ["P", "p"]:
            # 歩：1歩前
            add_step(0, f, acc)

        elif k in ["B", "b"]:
            # 角：斜め滑走
            for dx, dy in [(-1,-1), (1,-1), (-1,1), (1,1)]:
                add_slide(dx, dy, acc)

        elif k in ["R", "r"]:
            # 飛：縦横滑走
            for dx, dy in [(-1,0), (1,0), (0,-1), (0,1)]:
                add_slide(dx, dy, acc)

        elif k in ["+B", "+b"]:
            # 馬：角＋王の縦横1
            for dx, dy in [(-1,-1), (1,-1), (-1,1), (1,1)]:
                add_slide(dx, dy, acc)
            for dx, dy in [(-1,0), (1,0), (0,-1), (0,1)]:
                add_step(dx, dy, acc)

        elif k in ["+R", "+r"]:
            # 龍：飛＋王の斜め1
            for dx, dy in [(-1,0), (1,0), (0,-1), (0,1)]:
                add_slide(dx, dy, acc)
            for dx, dy in [(-1,-1), (1,-1), (-1,1), (1,1)]:
                add_step(dx, dy, acc)

        else:
            # 未定義駒は無し
            pass

        return acc

    def must_promote_if_reaches_dead_rank(self, piece: Piece, to_y: int) -> bool:
        # 歩/香は最終段、桂は最終段orその1つ手前に進んだら成り必須（動けなくなるため）
        base = piece.base_kind()
        if base in ["P", "L"]:
            if (piece.color == "B" and to_y == 0) or (piece.color == "W" and to_y == 8):
                return True
        if base == "N":
            if (piece.color == "B" and to_y <= 1) or (piece.color == "W" and to_y >= 7):
                return True
        return False

    def move(self, frm_x: int, frm_y: int, to_x: int, to_y: int, promote_req: bool) -> bool:
        p = self.get(frm_x, frm_y)
        if p is None:
            print("No piece on from-square.")
            return False
        if p.color != self.turn:
            print("Not your turn for that piece.")
            return False

        legal = self.moves_for(frm_x, frm_y)
        if (to_x, to_y) not in legal:
            print("Illegal move for that piece (basic rule).")
            return False

        target = self.get(to_x, to_y)
        if target is not None and target.color == self.turn:
            print("Cannot capture your own piece.")
            return False

        # 捕獲
        if target is not None:
            self.add_to_hand(self.turn, target)

        # 成り処理（任意/必須）
        will_promote = False
        if p.can_promote():
            zone = self.promo_zone(p.color)
            in_zone = (frm_y in zone) or (to_y in zone)
            if in_zone:
                if self.must_promote_if_reaches_dead_rank(p, to_y):
                    will_promote = True
                else:
                    will_promote = promote_req

        new_piece = p
        if will_promote:
            new_piece = Piece(PROMOTED_MAP[p.base_kind()], p.color)

        self.set(frm_x, frm_y, None)
        self.set(to_x, to_y, new_piece)
        self.turn = self.opponent(self.turn)
        return True

    def parse_and_play(self, s: str) -> bool:
        s = s.strip()
        if s.lower() in ["q", "quit", "exit"]:
            return False

        # 打ち： P*7f
        if "*" in s:
            try:
                pk, sq = s.split("*")
                pk = pk.strip().upper()
                to_x, to_y = sq_to_xy(sq.strip())
                ok = self.drop(pk, to_x, to_y)
                if not ok:
                    return True
                return True
            except Exception:
                print("Drop format: P*7f")
                return True

        # 移動： 7g7f or 7g7f+
        promote_req = s.endswith("+")
        if promote_req:
            s = s[:-1]

        if len(s) != 4:
            print("Move format: 7g7f or 7g7f+")
            return True

        try:
            frm = s[:2]
            to = s[2:]
            fx, fy = sq_to_xy(frm)
            tx, ty = sq_to_xy(to)
        except Exception:
            print("Square format must be like 7g.")
            return True

        self.move(fx, fy, tx, ty, promote_req)
        return True


def main():
    game = Shogi()
    while True:
        game.print_board()
        cmd = input("Your move (e.g., 7g7f, 7g7f+, P*7f, quit): ").strip()
        if not game.parse_and_play(cmd):
            print("Bye.")
            break

if __name__ == "__main__":
    main()
